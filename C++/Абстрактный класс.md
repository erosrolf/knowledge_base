
>Абстрактный класс в C++ - это класс, в котором объявлена хотя бы одна чисто виртуальная функция.

Абстрактный класс используют, когда необходимо создать семейство классов (_много разновидностей монстров в игре_), при этом было бы лучше **вынести общую реализацию и поведение** в отдельный класс. При такой тактике переопределить/дописать придется только специфичные для каждого класса методы (_у каждого монстра своя анимация удара/перемещения_) и/или расширить функциональность класса.

Но возникает возможность создать абстрактный класс, что противоречит архитектуре: как "выделанная общая часть" может быть полноценным классом? Ответ: никак, надо **запретить создавать подобный класс**. Для этого указывают один из методов как чистый виртуальный ( [pure virtual method](https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4) ), пример:

```C++
virtual void Abstr () = 0; // Чистая (пустая) виртуальная функция.
```

тем самым заставляя классы наследники определить реализацию для данного метода. Понятное дело, что такое "ограничение" вызывает зависимость и бьет по гибкости, поэтому в 90% случаев таким методом делают **деструктор**, так как кто-кто, а деструктор в классах, где есть наследование и виртуальные методы нужен всегда. Но не стоит забывать, что при вызове деструктора класс вызывает все деструкторы своих родителей, и поэтому мы **объязаны написать реализацию деструктора**, в случае определения его как чисто виртуального в абстрактном классе:
```C++
virtual ~IUnit() = 0 
{
}
```

Класс или его наследник перестаёт быть для компилятора абстрактным и экземпляр такого класса может быть создан, как только определена реализация для каждого pure virtual method.

### Отличие от интерфейса

Так как понятия "интерфейс" и "абстрактный класс" путают, приведу их отличия:

1. Каждый интерфейс является абстрактным классом, не каждый абстрактный класс — интерфейс (прим. #1).
2. Интерфейс содержит только public секцию, абстрактный класс не имеет ограничений.
3. Интерфейс содержит только pure virtual methods, абстрактный класс может содержать и поля, и обычные методы в добавок.
4. Интерфейс реализуют, абстрактный класс наследуют (для С++ прим. #1)

Примечение #1: так как **в С++ нету понятия интерфейс на уровне языка**, то программисты симулируют его поведение через абстрактный класс, **наследуя** его.
### [Пример](AbstractUnit.cc.md)