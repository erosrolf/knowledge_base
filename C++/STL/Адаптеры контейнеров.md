Кроме [последовательного контейнера](Последовательный%20контейнер%20(sequential%20container).md) есть так называемые адаптеры контейнеров (container adaptor). Технически они не являются контейнерами, а инкапсулируют один из вышеописанных контейнеров (например, [Vector](Vector.md)) и позвляют работать с этими контейнерами определенным образом.

_Адаптеры_ над стандартными контейнерами — это не самостоятельные контейнеры. Они используют какой-нибудь другой контейнер (например, дек или вектор) для хранения своих элементов, но при этом предоставляют свой набор функций для работы с ними. В стандартной библиотеке есть адаптеры std::stack, std::queue и std::priority_queue.

Это следующие типы

- std::**[stack](Stack.md)**<>: представляет структуру данных "стек"     **LIFO (last in first out)**
- std::****<>: представляет структуру данных "очередь"   **FIFO (first in first out)**
- std::**priority_queue**<>: также представляет очередь, но при этом ее элементы имеют приоритеты

По существу, адаптер — это механизм, заставляющий нечто одно действовать как нечто другое. Адаптер контейнера получает контейнер существующего типа и заставляет его действовать как другой.

К примеру, `std::vector` имеет методы `push_back`, `insert` и `pop_back`, но такие операции для стека не нужны, стеку нужны 3 операции(основные) `top`, `pop` и `push`. Но все эти операции реализованы через соответсвующие операции `std::vector`, который скрывается в недрах `std::stack`. Поэтому `stack` не выделяют как самостоятельный контейнер — он есть адаптер для `std::vector`.

В структуре данных [[Stack]] данные организованы по принципу: последний вошел в стек - первый вышел из стека, то есть `LIFO` (last in, first out).

Чтобы построить в C++ из списка стек, достаточно использовать методы либо `push_front`, `pop_front`, `front`, либо `push_back`, `pop_back`, `back` соответственно для методов стека `push`, `pop`, `top`.

Для этого просто в реализации данных методов стека следует вызывать соответствующие методы контейнера `std::list`.

Например, метод стека `pop` может быть реализован как вызов соответствующего метода контейнера `std::list`, который в примерах обозначен именем `c` от английского слова `container`:
```cpp
void pop() { c.pop_back(); }
```
или
```cpp
void pop() { c.pop_front(); }
```
Поэтому нет необходимости определять управление данными контейнера стек. Всю работу по управлению данными возьмет на себя контейнер `std::list`. Просто его методы, фактически, переименованы для **адаптации** к названиям методов контейнера стек.

Поэтому стек реализован не с нуля, а он просто является адаптацией класса `std::list` под логику работы стека, то есть стек - это **адаптер контейнера**.