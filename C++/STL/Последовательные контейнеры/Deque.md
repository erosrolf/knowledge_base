***
Один из контейнеров [STL](STL.md)
>для подключения: `#include <deque>`;

**Deque** представляет двухстороннюю очередь. (от англ. **Double-ended queue**)

Упорядочивает элементы заданного типа в линейном порядке и, подобно [Vector](Vector.md), обеспечивает быстрый произвольный доступ к любому элементу и эффективную вставку и удаление в конце контейнера.

Стандарт С++ определяет, что deque должен иметь:
* Сложность O(1) для push_back(), push_front(), pop_back(), pop_front()
* Сложность O(1) для произвольного доступа, через `оператор []`
* До N/2 сдвигов при операции вставки/удаления для deque размера N.

Эти ограничения естественным образом приводят к такой структуре, где каждый фрагмент памяти имеет постоянный размер:
![300](../../../Pasted%20image%2020231222174739.png)
Постоянный размер фрагмента важен, поскольку тогда можно легко сопоставить индекс массива с индексом внутри фрагмента за O(1). Частично пустыми могут быть только первый и последний фрагменты.

Всякий раз, когда происходит `push_back()` , запись добавляется внутрь последнего фрагмента или выделяется новый фрагмент. Та же самая процедура происходит в `push_front()` в первом фрагменте.

Однако во время операции `insert()` должно произойти множество сдвигов. Сдвиги происходят на всем пути от точки вставки до ближайшего конца дека — либо переднего, либо заднего, в зависимости от того, что ближе. Отсюда и ограничение « _до N/2 смен»_ .

Вы не можете ожидать вставки куска, потому что никакие фрагменты в середине дека не могут иметь пробелов.  
Вы не можете ожидать, что кусок будет расширяться, поскольку все куски имеют постоянный размер для быстрой индексации.

>[!info] Однако в отличие от объекта  [vector](../../../Последовательный%20контейнер/Vector.md), класс `deque` также поддерживает эффективную вставку и удаление в передней части контейнера.

>[!info]- Полезная информация
> [исходный код на github](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/stl_deque.h)